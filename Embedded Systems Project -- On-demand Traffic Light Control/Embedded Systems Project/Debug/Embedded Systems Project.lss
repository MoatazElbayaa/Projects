
Embedded Systems Project.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000078e  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000002  00800060  0000078e  00000822  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000005  00800062  00800062  00000824  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00000824  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  00000854  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000108  00000000  00000000  00000890  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   000012c5  00000000  00000000  00000998  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000810  00000000  00000000  00001c5d  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000009dc  00000000  00000000  0000246d  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000001f8  00000000  00000000  00002e4c  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000004b5  00000000  00000000  00003044  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00000616  00000000  00000000  000034f9  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000000b8  00000000  00000000  00003b0f  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
   4:	0c 94 20 02 	jmp	0x440	; 0x440 <__vector_1>
   8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
   c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  1c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
  54:	11 24       	eor	r1, r1
  56:	1f be       	out	0x3f, r1	; 63
  58:	cf e5       	ldi	r28, 0x5F	; 95
  5a:	d8 e0       	ldi	r29, 0x08	; 8
  5c:	de bf       	out	0x3e, r29	; 62
  5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
  60:	10 e0       	ldi	r17, 0x00	; 0
  62:	a0 e6       	ldi	r26, 0x60	; 96
  64:	b0 e0       	ldi	r27, 0x00	; 0
  66:	ee e8       	ldi	r30, 0x8E	; 142
  68:	f7 e0       	ldi	r31, 0x07	; 7
  6a:	02 c0       	rjmp	.+4      	; 0x70 <__do_copy_data+0x10>
  6c:	05 90       	lpm	r0, Z+
  6e:	0d 92       	st	X+, r0
  70:	a2 36       	cpi	r26, 0x62	; 98
  72:	b1 07       	cpc	r27, r17
  74:	d9 f7       	brne	.-10     	; 0x6c <__do_copy_data+0xc>

00000076 <__do_clear_bss>:
  76:	20 e0       	ldi	r18, 0x00	; 0
  78:	a2 e6       	ldi	r26, 0x62	; 98
  7a:	b0 e0       	ldi	r27, 0x00	; 0
  7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
  7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
  80:	a7 36       	cpi	r26, 0x67	; 103
  82:	b2 07       	cpc	r27, r18
  84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
  86:	0e 94 66 02 	call	0x4cc	; 0x4cc <main>
  8a:	0c 94 c5 03 	jmp	0x78a	; 0x78a <_exit>

0000008e <__bad_interrupt>:
  8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <App_init>:
/* App_init function is sets the system to its initial state            */
/************************************************************************/
void App_init(void)
{
	//Set pedestrians button direction to be input
	BUTTON_init(PEDESTRIANS_BUTTON_PORT,PEDESTRIANS_BUTTON_PIN);
  92:	62 e0       	ldi	r22, 0x02	; 2
  94:	84 e4       	ldi	r24, 0x44	; 68
  96:	0e 94 47 02 	call	0x48e	; 0x48e <BUTTON_init>
	
	//Set All LEDs to be output
	LED_init(carsGreen_LED_PORT,carsGreen_LED_PIN);
  9a:	60 e0       	ldi	r22, 0x00	; 0
  9c:	81 e4       	ldi	r24, 0x41	; 65
  9e:	0e 94 4b 02 	call	0x496	; 0x496 <LED_init>
	LED_init(carsYellow_LED_PORT,carsYellow_LED_PIN);
  a2:	61 e0       	ldi	r22, 0x01	; 1
  a4:	81 e4       	ldi	r24, 0x41	; 65
  a6:	0e 94 4b 02 	call	0x496	; 0x496 <LED_init>
	LED_init(carsRed_LED_PORT,carsRed_LED_PIN);
  aa:	62 e0       	ldi	r22, 0x02	; 2
  ac:	81 e4       	ldi	r24, 0x41	; 65
  ae:	0e 94 4b 02 	call	0x496	; 0x496 <LED_init>
	LED_init(pedestriansGreen_LED_PORT,pedestriansGreen_LED_PIN);
  b2:	60 e0       	ldi	r22, 0x00	; 0
  b4:	82 e4       	ldi	r24, 0x42	; 66
  b6:	0e 94 4b 02 	call	0x496	; 0x496 <LED_init>
	LED_init(pedestriansYellow_LED_PORT,pedestriansYellow_LED_PIN);
  ba:	61 e0       	ldi	r22, 0x01	; 1
  bc:	82 e4       	ldi	r24, 0x42	; 66
  be:	0e 94 4b 02 	call	0x496	; 0x496 <LED_init>
	LED_init(pedestriansRed_LED_PORT,pedestriansRed_LED_PIN);
  c2:	62 e0       	ldi	r22, 0x02	; 2
  c4:	82 e4       	ldi	r24, 0x42	; 66
  c6:	0e 94 4b 02 	call	0x496	; 0x496 <LED_init>
	
	/************************************************************************/
	/* Initialization of Interrupt                                          */
	/************************************************************************/
	//Enable global interrupts - by setting bit 7 in the status register to 1
	sei();
  ca:	78 94       	sei
	
	//Choose the external interrupt sense - sense on rising edge
	MCUCR |= (1<<ISC00)|(1<<ISC01);
  cc:	85 b7       	in	r24, 0x35	; 53
  ce:	83 60       	ori	r24, 0x03	; 3
  d0:	85 bf       	out	0x35, r24	; 53
	
	//Enable External interrupt 0 - INT0
	GICR |= (1<<INT0);
  d2:	8b b7       	in	r24, 0x3b	; 59
  d4:	80 64       	ori	r24, 0x40	; 64
  d6:	8b bf       	out	0x3b, r24	; 59
	
	/************************************************************************/
	/* Initialization of Timer0                                             */
	/************************************************************************/
	//Choose Timer mode
	TCCR0 = 0x00; //Normal Mode
  d8:	13 be       	out	0x33, r1	; 51
	//Set Timer initial value
	TCNT0 = 0x00;
  da:	12 be       	out	0x32, r1	; 50
	// Timer start -> setting the clock source
	TCCR0 |= (1<<0); //No Prescaler
  dc:	83 b7       	in	r24, 0x33	; 51
  de:	81 60       	ori	r24, 0x01	; 1
  e0:	83 bf       	out	0x33, r24	; 51
	
	
	//Turn All LEDs off
	LED_off(carsGreen_LED_PORT,carsGreen_LED_PIN);
  e2:	60 e0       	ldi	r22, 0x00	; 0
  e4:	81 e4       	ldi	r24, 0x41	; 65
  e6:	0e 94 53 02 	call	0x4a6	; 0x4a6 <LED_off>
	LED_off(carsYellow_LED_PORT,carsYellow_LED_PIN);
  ea:	61 e0       	ldi	r22, 0x01	; 1
  ec:	81 e4       	ldi	r24, 0x41	; 65
  ee:	0e 94 53 02 	call	0x4a6	; 0x4a6 <LED_off>
	LED_off(carsRed_LED_PORT,carsRed_LED_PIN);
  f2:	62 e0       	ldi	r22, 0x02	; 2
  f4:	81 e4       	ldi	r24, 0x41	; 65
  f6:	0e 94 53 02 	call	0x4a6	; 0x4a6 <LED_off>
	LED_off(pedestriansGreen_LED_PORT,pedestriansGreen_LED_PIN);
  fa:	60 e0       	ldi	r22, 0x00	; 0
  fc:	82 e4       	ldi	r24, 0x42	; 66
  fe:	0e 94 53 02 	call	0x4a6	; 0x4a6 <LED_off>
	LED_off(pedestriansYellow_LED_PORT,pedestriansYellow_LED_PIN);
 102:	61 e0       	ldi	r22, 0x01	; 1
 104:	82 e4       	ldi	r24, 0x42	; 66
 106:	0e 94 53 02 	call	0x4a6	; 0x4a6 <LED_off>
	LED_off(pedestriansRed_LED_PORT,pedestriansRed_LED_PIN);
 10a:	62 e0       	ldi	r22, 0x02	; 2
 10c:	82 e4       	ldi	r24, 0x42	; 66
 10e:	0e 94 53 02 	call	0x4a6	; 0x4a6 <LED_off>
 112:	08 95       	ret

00000114 <delay>:
/* the (Normal Mode) and continue the delays from Normal Mode when it   */
/* is switching to the ISR: (Pedestrian Mode)                           */
/************************************************************************/

void delay(uint16_t NUMBER_OF_OVERFLOWS)
{
 114:	ac 01       	movw	r20, r24
	//checking  ISR_Flag:
	//if ISR_Flag is 1,then this means that we was in ISR and we will change it to 0 
	//and overcome or break from the delay
	if(ISR_Flag==1)
 116:	80 91 65 00 	lds	r24, 0x0065	; 0x800065 <ISR_Flag>
 11a:	81 30       	cpi	r24, 0x01	; 1
 11c:	19 f4       	brne	.+6      	; 0x124 <delay+0x10>
	{
		ISR_Flag=0;
 11e:	10 92 65 00 	sts	0x0065, r1	; 0x800065 <ISR_Flag>
 122:	08 95       	ret
	}
	else
	{
		//Set Timer initial value
		TCNT0 = 0x00;
 124:	12 be       	out	0x32, r1	; 50
		
		while(overflowCounter<=NUMBER_OF_OVERFLOWS)
 126:	14 c0       	rjmp	.+40     	; 0x150 <delay+0x3c>
		{
			//Stop after one overflow -> 256 ms
			//Wait until the overflow flag to be set
			while ((TIFR & (1<<0)) == 0); //it will loop until the flag becomes 1
 128:	08 b6       	in	r0, 0x38	; 56
 12a:	00 fe       	sbrs	r0, 0
 12c:	fd cf       	rjmp	.-6      	; 0x128 <delay+0x14>
			
			//Clear the overflow flag
			TIFR |= (1<<0);
 12e:	98 b7       	in	r25, 0x38	; 56
 130:	91 60       	ori	r25, 0x01	; 1
 132:	98 bf       	out	0x38, r25	; 56
			
			//checking  ISR_Flag:
			//if ISR_Flag is 1,then this means that we was in ISR and we will change it to 0
			//and overcome or break from the delay
			if(ISR_Flag==1)
 134:	90 91 65 00 	lds	r25, 0x0065	; 0x800065 <ISR_Flag>
 138:	91 30       	cpi	r25, 0x01	; 1
 13a:	89 f0       	breq	.+34     	; 0x15e <delay+0x4a>
			{
				break;
			}
			
			overflowCounter++;
 13c:	20 91 63 00 	lds	r18, 0x0063	; 0x800063 <overflowCounter>
 140:	30 91 64 00 	lds	r19, 0x0064	; 0x800064 <overflowCounter+0x1>
 144:	2f 5f       	subi	r18, 0xFF	; 255
 146:	3f 4f       	sbci	r19, 0xFF	; 255
 148:	30 93 64 00 	sts	0x0064, r19	; 0x800064 <overflowCounter+0x1>
 14c:	20 93 63 00 	sts	0x0063, r18	; 0x800063 <overflowCounter>
	else
	{
		//Set Timer initial value
		TCNT0 = 0x00;
		
		while(overflowCounter<=NUMBER_OF_OVERFLOWS)
 150:	20 91 63 00 	lds	r18, 0x0063	; 0x800063 <overflowCounter>
 154:	30 91 64 00 	lds	r19, 0x0064	; 0x800064 <overflowCounter+0x1>
 158:	42 17       	cp	r20, r18
 15a:	53 07       	cpc	r21, r19
 15c:	28 f7       	brcc	.-54     	; 0x128 <delay+0x14>
			overflowCounter++;
			
		}
		
		//Clear overflowCounter
		overflowCounter=0;
 15e:	10 92 64 00 	sts	0x0064, r1	; 0x800064 <overflowCounter+0x1>
 162:	10 92 63 00 	sts	0x0063, r1	; 0x800063 <overflowCounter>
		
		//Timer stop
		TCCR0 = 0x00;
 166:	13 be       	out	0x33, r1	; 51
		// Timer start -> setting the clock source
		TCCR0 |= (1<<0); //No Prescaler
 168:	83 b7       	in	r24, 0x33	; 51
 16a:	81 60       	ori	r24, 0x01	; 1
 16c:	83 bf       	out	0x33, r24	; 51
 16e:	08 95       	ret

00000170 <yellowLED_Blinking>:
/* yellowLED_Blinking function is used for                              */
/* controlling Blinking of Yellow Lights        */
/************************************************************************/
void yellowLED_Blinking(uint8_t val)
{
	switch(val)
 170:	81 30       	cpi	r24, 0x01	; 1
 172:	09 f4       	brne	.+2      	; 0x176 <yellowLED_Blinking+0x6>
 174:	4d c0       	rjmp	.+154    	; 0x210 <yellowLED_Blinking+0xa0>
 176:	20 f0       	brcs	.+8      	; 0x180 <yellowLED_Blinking+0x10>
 178:	82 30       	cpi	r24, 0x02	; 2
 17a:	09 f4       	brne	.+2      	; 0x17e <yellowLED_Blinking+0xe>
 17c:	76 c0       	rjmp	.+236    	; 0x26a <yellowLED_Blinking+0xfa>
 17e:	08 95       	ret
	{
		case cars:
		{
			carsYellow_LED_status=ON;
 180:	81 e0       	ldi	r24, 0x01	; 1
 182:	80 93 66 00 	sts	0x0066, r24	; 0x800066 <carsYellow_LED_status>
			
			for(; i<=5; ++i)
 186:	1d c0       	rjmp	.+58     	; 0x1c2 <yellowLED_Blinking+0x52>
			{
				LED_on(carsYellow_LED_PORT,carsYellow_LED_PIN);
 188:	61 e0       	ldi	r22, 0x01	; 1
 18a:	81 e4       	ldi	r24, 0x41	; 65
 18c:	0e 94 4f 02 	call	0x49e	; 0x49e <LED_on>
				if(ISR_Flag==1) //After executing the ISR and return back, if the Normal mode was in yellow Blinking, then we will break from it
 190:	80 91 65 00 	lds	r24, 0x0065	; 0x800065 <ISR_Flag>
 194:	81 30       	cpi	r24, 0x01	; 1
 196:	c9 f0       	breq	.+50     	; 0x1ca <yellowLED_Blinking+0x5a>
				{
					break;
				}
				delay(HALF_SECOND);
 198:	82 ea       	ldi	r24, 0xA2	; 162
 19a:	97 e0       	ldi	r25, 0x07	; 7
 19c:	0e 94 8a 00 	call	0x114	; 0x114 <delay>
				
				LED_off(carsYellow_LED_PORT,carsYellow_LED_PIN);
 1a0:	61 e0       	ldi	r22, 0x01	; 1
 1a2:	81 e4       	ldi	r24, 0x41	; 65
 1a4:	0e 94 53 02 	call	0x4a6	; 0x4a6 <LED_off>
				if(ISR_Flag==1)
 1a8:	80 91 65 00 	lds	r24, 0x0065	; 0x800065 <ISR_Flag>
 1ac:	81 30       	cpi	r24, 0x01	; 1
 1ae:	69 f0       	breq	.+26     	; 0x1ca <yellowLED_Blinking+0x5a>
				{
					break;
				}
				delay(HALF_SECOND);
 1b0:	82 ea       	ldi	r24, 0xA2	; 162
 1b2:	97 e0       	ldi	r25, 0x07	; 7
 1b4:	0e 94 8a 00 	call	0x114	; 0x114 <delay>
	{
		case cars:
		{
			carsYellow_LED_status=ON;
			
			for(; i<=5; ++i)
 1b8:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <__DATA_REGION_ORIGIN__>
 1bc:	8f 5f       	subi	r24, 0xFF	; 255
 1be:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__DATA_REGION_ORIGIN__>
 1c2:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <__DATA_REGION_ORIGIN__>
 1c6:	86 30       	cpi	r24, 0x06	; 6
 1c8:	f8 f2       	brcs	.-66     	; 0x188 <yellowLED_Blinking+0x18>
				{
					break;
				}
				delay(HALF_SECOND);
			}
			i=1;
 1ca:	81 e0       	ldi	r24, 0x01	; 1
 1cc:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__DATA_REGION_ORIGIN__>
			carsYellow_LED_status=OFF;
 1d0:	10 92 66 00 	sts	0x0066, r1	; 0x800066 <carsYellow_LED_status>
			break;
 1d4:	08 95       	ret
		
		case pedestrians:
		{
			for(; i<=5; ++i)
			{
				LED_on(pedestriansYellow_LED_PORT,pedestriansYellow_LED_PIN);
 1d6:	61 e0       	ldi	r22, 0x01	; 1
 1d8:	82 e4       	ldi	r24, 0x42	; 66
 1da:	0e 94 4f 02 	call	0x49e	; 0x49e <LED_on>
				if(ISR_Flag==1)
 1de:	80 91 65 00 	lds	r24, 0x0065	; 0x800065 <ISR_Flag>
 1e2:	81 30       	cpi	r24, 0x01	; 1
 1e4:	c9 f0       	breq	.+50     	; 0x218 <yellowLED_Blinking+0xa8>
				{
					break;
				}
				delay(HALF_SECOND);
 1e6:	82 ea       	ldi	r24, 0xA2	; 162
 1e8:	97 e0       	ldi	r25, 0x07	; 7
 1ea:	0e 94 8a 00 	call	0x114	; 0x114 <delay>
				
				LED_off(pedestriansYellow_LED_PORT,pedestriansYellow_LED_PIN);
 1ee:	61 e0       	ldi	r22, 0x01	; 1
 1f0:	82 e4       	ldi	r24, 0x42	; 66
 1f2:	0e 94 53 02 	call	0x4a6	; 0x4a6 <LED_off>
				if(ISR_Flag==1)
 1f6:	80 91 65 00 	lds	r24, 0x0065	; 0x800065 <ISR_Flag>
 1fa:	81 30       	cpi	r24, 0x01	; 1
 1fc:	69 f0       	breq	.+26     	; 0x218 <yellowLED_Blinking+0xa8>
				{
					break;
				}
				delay(HALF_SECOND);
 1fe:	82 ea       	ldi	r24, 0xA2	; 162
 200:	97 e0       	ldi	r25, 0x07	; 7
 202:	0e 94 8a 00 	call	0x114	; 0x114 <delay>
			break;
		}
		
		case pedestrians:
		{
			for(; i<=5; ++i)
 206:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <__DATA_REGION_ORIGIN__>
 20a:	8f 5f       	subi	r24, 0xFF	; 255
 20c:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__DATA_REGION_ORIGIN__>
 210:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <__DATA_REGION_ORIGIN__>
 214:	86 30       	cpi	r24, 0x06	; 6
 216:	f8 f2       	brcs	.-66     	; 0x1d6 <yellowLED_Blinking+0x66>
				{
					break;
				}
				delay(HALF_SECOND);
			}
			i=1;
 218:	81 e0       	ldi	r24, 0x01	; 1
 21a:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__DATA_REGION_ORIGIN__>
			break;
 21e:	08 95       	ret
		
		case cars_and_pedestrians:
		{
			for(; i<=5; ++i)
			{
				LED_on(carsYellow_LED_PORT,carsYellow_LED_PIN);
 220:	61 e0       	ldi	r22, 0x01	; 1
 222:	81 e4       	ldi	r24, 0x41	; 65
 224:	0e 94 4f 02 	call	0x49e	; 0x49e <LED_on>
				LED_on(pedestriansYellow_LED_PORT,pedestriansYellow_LED_PIN);
 228:	61 e0       	ldi	r22, 0x01	; 1
 22a:	82 e4       	ldi	r24, 0x42	; 66
 22c:	0e 94 4f 02 	call	0x49e	; 0x49e <LED_on>
				if(ISR_Flag==1)
 230:	80 91 65 00 	lds	r24, 0x0065	; 0x800065 <ISR_Flag>
 234:	81 30       	cpi	r24, 0x01	; 1
 236:	e9 f0       	breq	.+58     	; 0x272 <yellowLED_Blinking+0x102>
				{
					break;
				}
				delay(HALF_SECOND);
 238:	82 ea       	ldi	r24, 0xA2	; 162
 23a:	97 e0       	ldi	r25, 0x07	; 7
 23c:	0e 94 8a 00 	call	0x114	; 0x114 <delay>
				
				LED_off(carsYellow_LED_PORT,carsYellow_LED_PIN);
 240:	61 e0       	ldi	r22, 0x01	; 1
 242:	81 e4       	ldi	r24, 0x41	; 65
 244:	0e 94 53 02 	call	0x4a6	; 0x4a6 <LED_off>
				LED_off(pedestriansYellow_LED_PORT,pedestriansYellow_LED_PIN);
 248:	61 e0       	ldi	r22, 0x01	; 1
 24a:	82 e4       	ldi	r24, 0x42	; 66
 24c:	0e 94 53 02 	call	0x4a6	; 0x4a6 <LED_off>
				if(ISR_Flag==1)
 250:	80 91 65 00 	lds	r24, 0x0065	; 0x800065 <ISR_Flag>
 254:	81 30       	cpi	r24, 0x01	; 1
 256:	69 f0       	breq	.+26     	; 0x272 <yellowLED_Blinking+0x102>
				{
					break;
				}
				delay(HALF_SECOND);
 258:	82 ea       	ldi	r24, 0xA2	; 162
 25a:	97 e0       	ldi	r25, 0x07	; 7
 25c:	0e 94 8a 00 	call	0x114	; 0x114 <delay>
			break;
		}
		
		case cars_and_pedestrians:
		{
			for(; i<=5; ++i)
 260:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <__DATA_REGION_ORIGIN__>
 264:	8f 5f       	subi	r24, 0xFF	; 255
 266:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__DATA_REGION_ORIGIN__>
 26a:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <__DATA_REGION_ORIGIN__>
 26e:	86 30       	cpi	r24, 0x06	; 6
 270:	b8 f2       	brcs	.-82     	; 0x220 <yellowLED_Blinking+0xb0>
				{
					break;
				}
				delay(HALF_SECOND);
			}
			i=1;
 272:	81 e0       	ldi	r24, 0x01	; 1
 274:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__DATA_REGION_ORIGIN__>
			carsYellow_LED_status=OFF;
 278:	10 92 66 00 	sts	0x0066, r1	; 0x800066 <carsYellow_LED_status>
 27c:	08 95       	ret

0000027e <App_start>:
/************************************************************************/
void App_start(void)
{
	while (1)
	{
		LED_off(carsYellow_LED_PORT,carsYellow_LED_PIN);
 27e:	61 e0       	ldi	r22, 0x01	; 1
 280:	81 e4       	ldi	r24, 0x41	; 65
 282:	0e 94 53 02 	call	0x4a6	; 0x4a6 <LED_off>
		LED_off(carsRed_LED_PORT,carsRed_LED_PIN);
 286:	62 e0       	ldi	r22, 0x02	; 2
 288:	81 e4       	ldi	r24, 0x41	; 65
 28a:	0e 94 53 02 	call	0x4a6	; 0x4a6 <LED_off>
		LED_on(carsGreen_LED_PORT, carsGreen_LED_PIN);
 28e:	60 e0       	ldi	r22, 0x00	; 0
 290:	81 e4       	ldi	r24, 0x41	; 65
 292:	0e 94 4f 02 	call	0x49e	; 0x49e <LED_on>
		LED_on(pedestriansRed_LED_PORT,pedestriansRed_LED_PIN);
 296:	62 e0       	ldi	r22, 0x02	; 2
 298:	82 e4       	ldi	r24, 0x42	; 66
 29a:	0e 94 4f 02 	call	0x49e	; 0x49e <LED_on>
		if(ISR_Flag==1)
 29e:	80 91 65 00 	lds	r24, 0x0065	; 0x800065 <ISR_Flag>
 2a2:	81 30       	cpi	r24, 0x01	; 1
 2a4:	19 f4       	brne	.+6      	; 0x2ac <App_start+0x2e>
		{
			ISR_Flag =0;
 2a6:	10 92 65 00 	sts	0x0065, r1	; 0x800065 <ISR_Flag>
			continue;
 2aa:	e9 cf       	rjmp	.-46     	; 0x27e <App_start>
		}
		delay(FIVE_SECONDS);
 2ac:	85 e5       	ldi	r24, 0x55	; 85
 2ae:	9c e4       	ldi	r25, 0x4C	; 76
 2b0:	0e 94 8a 00 	call	0x114	; 0x114 <delay>
		
		if(ISR_Flag==1)
 2b4:	80 91 65 00 	lds	r24, 0x0065	; 0x800065 <ISR_Flag>
 2b8:	81 30       	cpi	r24, 0x01	; 1
 2ba:	19 f4       	brne	.+6      	; 0x2c2 <App_start+0x44>
		{
			ISR_Flag =0;
 2bc:	10 92 65 00 	sts	0x0065, r1	; 0x800065 <ISR_Flag>
			continue;
 2c0:	de cf       	rjmp	.-68     	; 0x27e <App_start>
		}
		LED_off(carsGreen_LED_PORT, carsGreen_LED_PIN);
 2c2:	60 e0       	ldi	r22, 0x00	; 0
 2c4:	81 e4       	ldi	r24, 0x41	; 65
 2c6:	0e 94 53 02 	call	0x4a6	; 0x4a6 <LED_off>
		
		carsYellow_backwords_flag=0;
 2ca:	10 92 62 00 	sts	0x0062, r1	; 0x800062 <__data_end>
		yellowLED_Blinking(cars);
 2ce:	80 e0       	ldi	r24, 0x00	; 0
 2d0:	0e 94 b8 00 	call	0x170	; 0x170 <yellowLED_Blinking>
		
		
		if(ISR_Flag==1)
 2d4:	80 91 65 00 	lds	r24, 0x0065	; 0x800065 <ISR_Flag>
 2d8:	81 30       	cpi	r24, 0x01	; 1
 2da:	19 f4       	brne	.+6      	; 0x2e2 <App_start+0x64>
		{
			ISR_Flag =0;
 2dc:	10 92 65 00 	sts	0x0065, r1	; 0x800065 <ISR_Flag>
			continue;
 2e0:	ce cf       	rjmp	.-100    	; 0x27e <App_start>
		}
		LED_off(carsYellow_LED_PORT,carsYellow_LED_PIN);
 2e2:	61 e0       	ldi	r22, 0x01	; 1
 2e4:	81 e4       	ldi	r24, 0x41	; 65
 2e6:	0e 94 53 02 	call	0x4a6	; 0x4a6 <LED_off>
		LED_on(carsRed_LED_PORT,carsRed_LED_PIN);
 2ea:	62 e0       	ldi	r22, 0x02	; 2
 2ec:	81 e4       	ldi	r24, 0x41	; 65
 2ee:	0e 94 4f 02 	call	0x49e	; 0x49e <LED_on>
		if(ISR_Flag==1)
 2f2:	80 91 65 00 	lds	r24, 0x0065	; 0x800065 <ISR_Flag>
 2f6:	81 30       	cpi	r24, 0x01	; 1
 2f8:	19 f4       	brne	.+6      	; 0x300 <App_start+0x82>
		{
			ISR_Flag =0;
 2fa:	10 92 65 00 	sts	0x0065, r1	; 0x800065 <ISR_Flag>
			continue;
 2fe:	bf cf       	rjmp	.-130    	; 0x27e <App_start>
		}
		delay(FIVE_SECONDS);
 300:	85 e5       	ldi	r24, 0x55	; 85
 302:	9c e4       	ldi	r25, 0x4C	; 76
 304:	0e 94 8a 00 	call	0x114	; 0x114 <delay>
		
		LED_off(carsRed_LED_PORT,carsRed_LED_PIN);
 308:	62 e0       	ldi	r22, 0x02	; 2
 30a:	81 e4       	ldi	r24, 0x41	; 65
 30c:	0e 94 53 02 	call	0x4a6	; 0x4a6 <LED_off>
		
		carsYellow_backwords_flag=1;
 310:	81 e0       	ldi	r24, 0x01	; 1
 312:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__data_end>
		yellowLED_Blinking(cars);
 316:	80 e0       	ldi	r24, 0x00	; 0
 318:	0e 94 b8 00 	call	0x170	; 0x170 <yellowLED_Blinking>
 31c:	b0 cf       	rjmp	.-160    	; 0x27e <App_start>

0000031e <pedestrianMode>:
	/************************************************************************************/
	/* Change from normal mode to pedestrian mode when the pedestrian button is pressed */
	/************************************************************************************/
	
	//If pressed when the cars' Red LED is on
	if( LED_status(carsRed_LED_PORT,carsRed_LED_PIN) == ON )
 31e:	62 e0       	ldi	r22, 0x02	; 2
 320:	81 e4       	ldi	r24, 0x41	; 65
 322:	0e 94 57 02 	call	0x4ae	; 0x4ae <LED_status>
 326:	81 30       	cpi	r24, 0x01	; 1
 328:	69 f4       	brne	.+26     	; 0x344 <pedestrianMode+0x26>
	{
		//the pedestrian's Green LED and the cars' Red LEDs will be on for five seconds
		//cars' Red LED is already ON
		LED_off(pedestriansRed_LED_PORT,pedestriansRed_LED_PIN);
 32a:	62 e0       	ldi	r22, 0x02	; 2
 32c:	82 e4       	ldi	r24, 0x42	; 66
 32e:	0e 94 53 02 	call	0x4a6	; 0x4a6 <LED_off>
		LED_on(pedestriansGreen_LED_PORT,pedestriansGreen_LED_PIN);
 332:	60 e0       	ldi	r22, 0x00	; 0
 334:	82 e4       	ldi	r24, 0x42	; 66
 336:	0e 94 4f 02 	call	0x49e	; 0x49e <LED_on>
		
		delay(FIVE_SECONDS);
 33a:	85 e5       	ldi	r24, 0x55	; 85
 33c:	9c e4       	ldi	r25, 0x4C	; 76
 33e:	0e 94 8a 00 	call	0x114	; 0x114 <delay>
 342:	6a c0       	rjmp	.+212    	; 0x418 <__EEPROM_REGION_LENGTH__+0x18>
	}
	/*If pressed when the cars' Green LED is on or the cars' Yellow LED is blinking,the pedestrian Red LED will be on 
	then both Yellow LEDs start to blink for five seconds, 
	then the cars' Red LED and pedestrian Green LEDs are on for five seconds, 
	this means that pedestrian must wait until the Green LED is on.*/
	else if(LED_status(carsGreen_LED_PORT,carsGreen_LED_PIN)==ON || carsYellow_LED_status==ON)
 344:	60 e0       	ldi	r22, 0x00	; 0
 346:	81 e4       	ldi	r24, 0x41	; 65
 348:	0e 94 57 02 	call	0x4ae	; 0x4ae <LED_status>
 34c:	81 30       	cpi	r24, 0x01	; 1
 34e:	29 f0       	breq	.+10     	; 0x35a <pedestrianMode+0x3c>
 350:	80 91 66 00 	lds	r24, 0x0066	; 0x800066 <carsYellow_LED_status>
 354:	81 30       	cpi	r24, 0x01	; 1
 356:	09 f0       	breq	.+2      	; 0x35a <pedestrianMode+0x3c>
 358:	5f c0       	rjmp	.+190    	; 0x418 <__EEPROM_REGION_LENGTH__+0x18>
	{
		if(LED_status(carsGreen_LED_PORT,carsGreen_LED_PIN)==ON)
 35a:	60 e0       	ldi	r22, 0x00	; 0
 35c:	81 e4       	ldi	r24, 0x41	; 65
 35e:	0e 94 57 02 	call	0x4ae	; 0x4ae <LED_status>
 362:	81 30       	cpi	r24, 0x01	; 1
 364:	61 f4       	brne	.+24     	; 0x37e <pedestrianMode+0x60>
		{
			//The pedestrian Red LED will be on
			LED_on(pedestriansRed_LED_PORT,pedestriansRed_LED_PIN);
 366:	62 e0       	ldi	r22, 0x02	; 2
 368:	82 e4       	ldi	r24, 0x42	; 66
 36a:	0e 94 4f 02 	call	0x49e	; 0x49e <LED_on>
		
			//then both Yellow LEDs start to blink for five seconds
			yellowLED_Blinking(cars_and_pedestrians);
 36e:	82 e0       	ldi	r24, 0x02	; 2
 370:	0e 94 b8 00 	call	0x170	; 0x170 <yellowLED_Blinking>
			LED_off(carsGreen_LED_PORT,carsGreen_LED_PIN);
 374:	60 e0       	ldi	r22, 0x00	; 0
 376:	81 e4       	ldi	r24, 0x41	; 65
 378:	0e 94 53 02 	call	0x4a6	; 0x4a6 <LED_off>
 37c:	29 c0       	rjmp	.+82     	; 0x3d0 <pedestrianMode+0xb2>
		}
		
		else if(carsYellow_LED_status==ON && carsYellow_backwords_flag == 0)
 37e:	80 91 66 00 	lds	r24, 0x0066	; 0x800066 <carsYellow_LED_status>
 382:	81 30       	cpi	r24, 0x01	; 1
 384:	61 f4       	brne	.+24     	; 0x39e <pedestrianMode+0x80>
 386:	90 91 62 00 	lds	r25, 0x0062	; 0x800062 <__data_end>
 38a:	91 11       	cpse	r25, r1
 38c:	08 c0       	rjmp	.+16     	; 0x39e <pedestrianMode+0x80>
		{
			//The pedestrian Red LED will be on
			LED_on(pedestriansRed_LED_PORT,pedestriansRed_LED_PIN);
 38e:	62 e0       	ldi	r22, 0x02	; 2
 390:	82 e4       	ldi	r24, 0x42	; 66
 392:	0e 94 4f 02 	call	0x49e	; 0x49e <LED_on>
			
			//if the ISR has been called while the main function was within a delay,
			//then we will complete the previous delay till it becomes complete (5 seconds as the cars' Green LED was On)
			yellowLED_Blinking(cars_and_pedestrians);
 396:	82 e0       	ldi	r24, 0x02	; 2
 398:	0e 94 b8 00 	call	0x170	; 0x170 <yellowLED_Blinking>
 39c:	19 c0       	rjmp	.+50     	; 0x3d0 <pedestrianMode+0xb2>
			
		}
		
		else if(carsYellow_LED_status==ON && carsYellow_backwords_flag == 1)
 39e:	81 30       	cpi	r24, 0x01	; 1
 3a0:	b9 f4       	brne	.+46     	; 0x3d0 <pedestrianMode+0xb2>
 3a2:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__data_end>
 3a6:	81 30       	cpi	r24, 0x01	; 1
 3a8:	99 f4       	brne	.+38     	; 0x3d0 <pedestrianMode+0xb2>
		{
			//complete the previous delay1st
			yellowLED_Blinking(cars_and_pedestrians);
 3aa:	82 e0       	ldi	r24, 0x02	; 2
 3ac:	0e 94 b8 00 	call	0x170	; 0x170 <yellowLED_Blinking>
			
			
			LED_on(carsGreen_LED_PORT, carsGreen_LED_PIN);
 3b0:	60 e0       	ldi	r22, 0x00	; 0
 3b2:	81 e4       	ldi	r24, 0x41	; 65
 3b4:	0e 94 4f 02 	call	0x49e	; 0x49e <LED_on>
			yellowLED_Blinking(pedestrians);
 3b8:	81 e0       	ldi	r24, 0x01	; 1
 3ba:	0e 94 b8 00 	call	0x170	; 0x170 <yellowLED_Blinking>
			//delay(FIVE_SECONDS);

			LED_off(carsGreen_LED_PORT, carsGreen_LED_PIN);
 3be:	60 e0       	ldi	r22, 0x00	; 0
 3c0:	81 e4       	ldi	r24, 0x41	; 65
 3c2:	0e 94 53 02 	call	0x4a6	; 0x4a6 <LED_off>
			yellowLED_Blinking(cars_and_pedestrians);
 3c6:	82 e0       	ldi	r24, 0x02	; 2
 3c8:	0e 94 b8 00 	call	0x170	; 0x170 <yellowLED_Blinking>
			carsYellow_backwords_flag = 0;
 3cc:	10 92 62 00 	sts	0x0062, r1	; 0x800062 <__data_end>
		}
		
		
		//After 5 Seconds delay of Yellow LEDs On
		LED_off(carsYellow_LED_PORT,carsYellow_LED_PIN);
 3d0:	61 e0       	ldi	r22, 0x01	; 1
 3d2:	81 e4       	ldi	r24, 0x41	; 65
 3d4:	0e 94 53 02 	call	0x4a6	; 0x4a6 <LED_off>
		
		//then the cars' Red LED and pedestrian Green LEDs are on for five seconds,
		LED_on(carsRed_LED_PORT,carsRed_LED_PIN);
 3d8:	62 e0       	ldi	r22, 0x02	; 2
 3da:	81 e4       	ldi	r24, 0x41	; 65
 3dc:	0e 94 4f 02 	call	0x49e	; 0x49e <LED_on>
		
		//
		delay(HALF_SECOND);
 3e0:	82 ea       	ldi	r24, 0xA2	; 162
 3e2:	97 e0       	ldi	r25, 0x07	; 7
 3e4:	0e 94 8a 00 	call	0x114	; 0x114 <delay>
		
		LED_off(pedestriansRed_LED_PORT,pedestriansRed_LED_PIN);
 3e8:	62 e0       	ldi	r22, 0x02	; 2
 3ea:	82 e4       	ldi	r24, 0x42	; 66
 3ec:	0e 94 53 02 	call	0x4a6	; 0x4a6 <LED_off>
		LED_on(pedestriansYellow_LED_PORT,pedestriansYellow_LED_PIN);
 3f0:	61 e0       	ldi	r22, 0x01	; 1
 3f2:	82 e4       	ldi	r24, 0x42	; 66
 3f4:	0e 94 4f 02 	call	0x49e	; 0x49e <LED_on>
		
		delay(HALF_SECOND);
 3f8:	82 ea       	ldi	r24, 0xA2	; 162
 3fa:	97 e0       	ldi	r25, 0x07	; 7
 3fc:	0e 94 8a 00 	call	0x114	; 0x114 <delay>
		
		LED_off(pedestriansYellow_LED_PORT,pedestriansYellow_LED_PIN);
 400:	61 e0       	ldi	r22, 0x01	; 1
 402:	82 e4       	ldi	r24, 0x42	; 66
 404:	0e 94 53 02 	call	0x4a6	; 0x4a6 <LED_off>
		LED_on(pedestriansGreen_LED_PORT,pedestriansGreen_LED_PIN);
 408:	60 e0       	ldi	r22, 0x00	; 0
 40a:	82 e4       	ldi	r24, 0x42	; 66
 40c:	0e 94 4f 02 	call	0x49e	; 0x49e <LED_on>
		
		delay(FIVE_SECONDS);
 410:	85 e5       	ldi	r24, 0x55	; 85
 412:	9c e4       	ldi	r25, 0x4C	; 76
 414:	0e 94 8a 00 	call	0x114	; 0x114 <delay>
	}
	
	LED_off(carsRed_LED_PORT,carsRed_LED_PIN);
 418:	62 e0       	ldi	r22, 0x02	; 2
 41a:	81 e4       	ldi	r24, 0x41	; 65
 41c:	0e 94 53 02 	call	0x4a6	; 0x4a6 <LED_off>
	//both Yellow LEDs start blinking for 5 seconds and the pedestrian's Green LED is still on
	yellowLED_Blinking(cars_and_pedestrians);
 420:	82 e0       	ldi	r24, 0x02	; 2
 422:	0e 94 b8 00 	call	0x170	; 0x170 <yellowLED_Blinking>
	
	// the pedestrian Green LED will be off and both the pedestrian Red LED and the cars' Green LED will be on.
	LED_off(pedestriansGreen_LED_PORT,pedestriansGreen_LED_PIN);
 426:	60 e0       	ldi	r22, 0x00	; 0
 428:	82 e4       	ldi	r24, 0x42	; 66
 42a:	0e 94 53 02 	call	0x4a6	; 0x4a6 <LED_off>
	LED_off(pedestriansYellow_LED_PORT,pedestriansYellow_LED_PIN);
 42e:	61 e0       	ldi	r22, 0x01	; 1
 430:	82 e4       	ldi	r24, 0x42	; 66
 432:	0e 94 53 02 	call	0x4a6	; 0x4a6 <LED_off>
	LED_on(pedestriansRed_LED_PORT,pedestriansRed_LED_PIN);	
 436:	62 e0       	ldi	r22, 0x02	; 2
 438:	82 e4       	ldi	r24, 0x42	; 66
 43a:	0e 94 4f 02 	call	0x49e	; 0x49e <LED_on>
 43e:	08 95       	ret

00000440 <__vector_1>:

/************************************************************************/
/* ISR ( Interrupt Serves Routine), it will call the pedestrianMode     */
/************************************************************************/
ISR(EXT_INT_0)
{
 440:	1f 92       	push	r1
 442:	0f 92       	push	r0
 444:	0f b6       	in	r0, 0x3f	; 63
 446:	0f 92       	push	r0
 448:	11 24       	eor	r1, r1
 44a:	2f 93       	push	r18
 44c:	3f 93       	push	r19
 44e:	4f 93       	push	r20
 450:	5f 93       	push	r21
 452:	6f 93       	push	r22
 454:	7f 93       	push	r23
 456:	8f 93       	push	r24
 458:	9f 93       	push	r25
 45a:	af 93       	push	r26
 45c:	bf 93       	push	r27
 45e:	ef 93       	push	r30
 460:	ff 93       	push	r31
	pedestrianMode();
 462:	0e 94 8f 01 	call	0x31e	; 0x31e <pedestrianMode>
	//setting the ISR_Flag to 1, to indicate that the ISR has been executed and to not complete the delay from the normal mode after the  ISR
	ISR_Flag=1;
 466:	81 e0       	ldi	r24, 0x01	; 1
 468:	80 93 65 00 	sts	0x0065, r24	; 0x800065 <ISR_Flag>
}
 46c:	ff 91       	pop	r31
 46e:	ef 91       	pop	r30
 470:	bf 91       	pop	r27
 472:	af 91       	pop	r26
 474:	9f 91       	pop	r25
 476:	8f 91       	pop	r24
 478:	7f 91       	pop	r23
 47a:	6f 91       	pop	r22
 47c:	5f 91       	pop	r21
 47e:	4f 91       	pop	r20
 480:	3f 91       	pop	r19
 482:	2f 91       	pop	r18
 484:	0f 90       	pop	r0
 486:	0f be       	out	0x3f, r0	; 63
 488:	0f 90       	pop	r0
 48a:	1f 90       	pop	r1
 48c:	18 95       	reti

0000048e <BUTTON_init>:
/*                    Functions definitions                             */
/************************************************************************/

void BUTTON_init(uint8_t buttonPort, uint8_t buttonPin) //Button is an input device
{
	DIO_init(buttonPort,buttonPin,IN); //Button is an input device, so we will initialize it as input
 48e:	40 e0       	ldi	r20, 0x00	; 0
 490:	0e 94 6d 02 	call	0x4da	; 0x4da <DIO_init>
 494:	08 95       	ret

00000496 <LED_init>:
{
	DIO_write(ledPort, ledPin, LOW);
}
void LED_toggle(uint8_t ledPort, uint8_t ledPin)
{
	DIO_toggle(ledPort, ledPin);
 496:	41 e0       	ldi	r20, 0x01	; 1
 498:	0e 94 6d 02 	call	0x4da	; 0x4da <DIO_init>
 49c:	08 95       	ret

0000049e <LED_on>:
 49e:	41 e0       	ldi	r20, 0x01	; 1
 4a0:	0e 94 e7 02 	call	0x5ce	; 0x5ce <DIO_write>
 4a4:	08 95       	ret

000004a6 <LED_off>:
 4a6:	40 e0       	ldi	r20, 0x00	; 0
 4a8:	0e 94 e7 02 	call	0x5ce	; 0x5ce <DIO_write>
 4ac:	08 95       	ret

000004ae <LED_status>:
}
uint8_t LED_status(uint8_t ledPort, uint8_t ledPin)
{
 4ae:	cf 93       	push	r28
 4b0:	df 93       	push	r29
 4b2:	1f 92       	push	r1
 4b4:	cd b7       	in	r28, 0x3d	; 61
 4b6:	de b7       	in	r29, 0x3e	; 62
	uint8_t ledStatus;
	DIO_read(ledPort, ledPin, &ledStatus);
 4b8:	ae 01       	movw	r20, r28
 4ba:	4f 5f       	subi	r20, 0xFF	; 255
 4bc:	5f 4f       	sbci	r21, 0xFF	; 255
 4be:	0e 94 61 03 	call	0x6c2	; 0x6c2 <DIO_read>
	return ledStatus;
}
 4c2:	89 81       	ldd	r24, Y+1	; 0x01
 4c4:	0f 90       	pop	r0
 4c6:	df 91       	pop	r29
 4c8:	cf 91       	pop	r28
 4ca:	08 95       	ret

000004cc <main>:

int main(void)
{
    /* Replace with your application code */
	
	App_init();
 4cc:	0e 94 49 00 	call	0x92	; 0x92 <App_init>
	App_start();
 4d0:	0e 94 3f 01 	call	0x27e	; 0x27e <App_start>
	
}
 4d4:	80 e0       	ldi	r24, 0x00	; 0
 4d6:	90 e0       	ldi	r25, 0x00	; 0
 4d8:	08 95       	ret

000004da <DIO_init>:
/*                    Functions definitions                             */
/************************************************************************/

void DIO_init(uint8_t portNumber, uint8_t pinNumber, uint8_t direction)
{
	switch(portNumber)
 4da:	82 34       	cpi	r24, 0x42	; 66
 4dc:	31 f1       	breq	.+76     	; 0x52a <DIO_init+0x50>
 4de:	18 f4       	brcc	.+6      	; 0x4e6 <DIO_init+0xc>
 4e0:	81 34       	cpi	r24, 0x41	; 65
 4e2:	39 f0       	breq	.+14     	; 0x4f2 <DIO_init+0x18>
 4e4:	08 95       	ret
 4e6:	83 34       	cpi	r24, 0x43	; 67
 4e8:	e1 f1       	breq	.+120    	; 0x562 <DIO_init+0x88>
 4ea:	84 34       	cpi	r24, 0x44	; 68
 4ec:	09 f4       	brne	.+2      	; 0x4f0 <DIO_init+0x16>
 4ee:	54 c0       	rjmp	.+168    	; 0x598 <DIO_init+0xbe>
 4f0:	08 95       	ret
	{
		case PORT_A:
			if (direction==IN)
 4f2:	41 11       	cpse	r20, r1
 4f4:	0c c0       	rjmp	.+24     	; 0x50e <DIO_init+0x34>
			{
				DDRA &=~(1<<pinNumber);//Input
 4f6:	2a b3       	in	r18, 0x1a	; 26
 4f8:	81 e0       	ldi	r24, 0x01	; 1
 4fa:	90 e0       	ldi	r25, 0x00	; 0
 4fc:	02 c0       	rjmp	.+4      	; 0x502 <DIO_init+0x28>
 4fe:	88 0f       	add	r24, r24
 500:	99 1f       	adc	r25, r25
 502:	6a 95       	dec	r22
 504:	e2 f7       	brpl	.-8      	; 0x4fe <DIO_init+0x24>
 506:	80 95       	com	r24
 508:	82 23       	and	r24, r18
 50a:	8a bb       	out	0x1a, r24	; 26
 50c:	08 95       	ret
			}
			else if(direction==OUT)
 50e:	41 30       	cpi	r20, 0x01	; 1
 510:	09 f0       	breq	.+2      	; 0x514 <DIO_init+0x3a>
 512:	5c c0       	rjmp	.+184    	; 0x5cc <DIO_init+0xf2>
			{
				DDRA |=(1<<pinNumber);//Output
 514:	2a b3       	in	r18, 0x1a	; 26
 516:	81 e0       	ldi	r24, 0x01	; 1
 518:	90 e0       	ldi	r25, 0x00	; 0
 51a:	02 c0       	rjmp	.+4      	; 0x520 <DIO_init+0x46>
 51c:	88 0f       	add	r24, r24
 51e:	99 1f       	adc	r25, r25
 520:	6a 95       	dec	r22
 522:	e2 f7       	brpl	.-8      	; 0x51c <DIO_init+0x42>
 524:	82 2b       	or	r24, r18
 526:	8a bb       	out	0x1a, r24	; 26
 528:	08 95       	ret
				//Error handling Technique
			}
		break;
		
		case PORT_B:
		if (direction==IN)
 52a:	41 11       	cpse	r20, r1
 52c:	0c c0       	rjmp	.+24     	; 0x546 <DIO_init+0x6c>
		{
			DDRB &=~(1<<pinNumber);//Input
 52e:	27 b3       	in	r18, 0x17	; 23
 530:	81 e0       	ldi	r24, 0x01	; 1
 532:	90 e0       	ldi	r25, 0x00	; 0
 534:	02 c0       	rjmp	.+4      	; 0x53a <DIO_init+0x60>
 536:	88 0f       	add	r24, r24
 538:	99 1f       	adc	r25, r25
 53a:	6a 95       	dec	r22
 53c:	e2 f7       	brpl	.-8      	; 0x536 <DIO_init+0x5c>
 53e:	80 95       	com	r24
 540:	82 23       	and	r24, r18
 542:	87 bb       	out	0x17, r24	; 23
 544:	08 95       	ret
		}
		else if(direction==OUT)
 546:	41 30       	cpi	r20, 0x01	; 1
 548:	09 f0       	breq	.+2      	; 0x54c <DIO_init+0x72>
 54a:	40 c0       	rjmp	.+128    	; 0x5cc <DIO_init+0xf2>
		{
			DDRB |=(1<<pinNumber);//Output
 54c:	27 b3       	in	r18, 0x17	; 23
 54e:	81 e0       	ldi	r24, 0x01	; 1
 550:	90 e0       	ldi	r25, 0x00	; 0
 552:	02 c0       	rjmp	.+4      	; 0x558 <DIO_init+0x7e>
 554:	88 0f       	add	r24, r24
 556:	99 1f       	adc	r25, r25
 558:	6a 95       	dec	r22
 55a:	e2 f7       	brpl	.-8      	; 0x554 <DIO_init+0x7a>
 55c:	82 2b       	or	r24, r18
 55e:	87 bb       	out	0x17, r24	; 23
 560:	08 95       	ret
			//Error handling Technique
		}
		break;
		
		case PORT_C:
		if (direction==IN)
 562:	41 11       	cpse	r20, r1
 564:	0c c0       	rjmp	.+24     	; 0x57e <DIO_init+0xa4>
		{
			DDRC &=~(1<<pinNumber);//Input
 566:	24 b3       	in	r18, 0x14	; 20
 568:	81 e0       	ldi	r24, 0x01	; 1
 56a:	90 e0       	ldi	r25, 0x00	; 0
 56c:	02 c0       	rjmp	.+4      	; 0x572 <DIO_init+0x98>
 56e:	88 0f       	add	r24, r24
 570:	99 1f       	adc	r25, r25
 572:	6a 95       	dec	r22
 574:	e2 f7       	brpl	.-8      	; 0x56e <DIO_init+0x94>
 576:	80 95       	com	r24
 578:	82 23       	and	r24, r18
 57a:	84 bb       	out	0x14, r24	; 20
 57c:	08 95       	ret
		}
		else if(direction==OUT)
 57e:	41 30       	cpi	r20, 0x01	; 1
 580:	29 f5       	brne	.+74     	; 0x5cc <DIO_init+0xf2>
		{
			DDRC |=(1<<pinNumber);//Output
 582:	24 b3       	in	r18, 0x14	; 20
 584:	81 e0       	ldi	r24, 0x01	; 1
 586:	90 e0       	ldi	r25, 0x00	; 0
 588:	02 c0       	rjmp	.+4      	; 0x58e <DIO_init+0xb4>
 58a:	88 0f       	add	r24, r24
 58c:	99 1f       	adc	r25, r25
 58e:	6a 95       	dec	r22
 590:	e2 f7       	brpl	.-8      	; 0x58a <DIO_init+0xb0>
 592:	82 2b       	or	r24, r18
 594:	84 bb       	out	0x14, r24	; 20
 596:	08 95       	ret
			//Error handling Technique
		}
		break;
		
		case PORT_D:
		if (direction==IN)
 598:	41 11       	cpse	r20, r1
 59a:	0c c0       	rjmp	.+24     	; 0x5b4 <DIO_init+0xda>
		{
			DDRD &=~(1<<pinNumber);//Input
 59c:	21 b3       	in	r18, 0x11	; 17
 59e:	81 e0       	ldi	r24, 0x01	; 1
 5a0:	90 e0       	ldi	r25, 0x00	; 0
 5a2:	02 c0       	rjmp	.+4      	; 0x5a8 <DIO_init+0xce>
 5a4:	88 0f       	add	r24, r24
 5a6:	99 1f       	adc	r25, r25
 5a8:	6a 95       	dec	r22
 5aa:	e2 f7       	brpl	.-8      	; 0x5a4 <DIO_init+0xca>
 5ac:	80 95       	com	r24
 5ae:	82 23       	and	r24, r18
 5b0:	81 bb       	out	0x11, r24	; 17
 5b2:	08 95       	ret
		}
		else if(direction==OUT)
 5b4:	41 30       	cpi	r20, 0x01	; 1
 5b6:	51 f4       	brne	.+20     	; 0x5cc <DIO_init+0xf2>
		{
			DDRD |=(1<<pinNumber);//Output
 5b8:	21 b3       	in	r18, 0x11	; 17
 5ba:	81 e0       	ldi	r24, 0x01	; 1
 5bc:	90 e0       	ldi	r25, 0x00	; 0
 5be:	02 c0       	rjmp	.+4      	; 0x5c4 <DIO_init+0xea>
 5c0:	88 0f       	add	r24, r24
 5c2:	99 1f       	adc	r25, r25
 5c4:	6a 95       	dec	r22
 5c6:	e2 f7       	brpl	.-8      	; 0x5c0 <DIO_init+0xe6>
 5c8:	82 2b       	or	r24, r18
 5ca:	81 bb       	out	0x11, r24	; 17
 5cc:	08 95       	ret

000005ce <DIO_write>:
		break;		
	}
}
void DIO_write(uint8_t portNumber, uint8_t pinNumber, uint8_t value)
{
	switch(portNumber)
 5ce:	82 34       	cpi	r24, 0x42	; 66
 5d0:	31 f1       	breq	.+76     	; 0x61e <DIO_write+0x50>
 5d2:	18 f4       	brcc	.+6      	; 0x5da <DIO_write+0xc>
 5d4:	81 34       	cpi	r24, 0x41	; 65
 5d6:	39 f0       	breq	.+14     	; 0x5e6 <DIO_write+0x18>
 5d8:	08 95       	ret
 5da:	83 34       	cpi	r24, 0x43	; 67
 5dc:	e1 f1       	breq	.+120    	; 0x656 <DIO_write+0x88>
 5de:	84 34       	cpi	r24, 0x44	; 68
 5e0:	09 f4       	brne	.+2      	; 0x5e4 <DIO_write+0x16>
 5e2:	54 c0       	rjmp	.+168    	; 0x68c <DIO_write+0xbe>
 5e4:	08 95       	ret
	{
		case PORT_A:
		if (value==LOW)
 5e6:	41 11       	cpse	r20, r1
 5e8:	0c c0       	rjmp	.+24     	; 0x602 <DIO_write+0x34>
		{
			PORTA &=~(1<<pinNumber);//Write 0
 5ea:	2b b3       	in	r18, 0x1b	; 27
 5ec:	81 e0       	ldi	r24, 0x01	; 1
 5ee:	90 e0       	ldi	r25, 0x00	; 0
 5f0:	02 c0       	rjmp	.+4      	; 0x5f6 <DIO_write+0x28>
 5f2:	88 0f       	add	r24, r24
 5f4:	99 1f       	adc	r25, r25
 5f6:	6a 95       	dec	r22
 5f8:	e2 f7       	brpl	.-8      	; 0x5f2 <DIO_write+0x24>
 5fa:	80 95       	com	r24
 5fc:	82 23       	and	r24, r18
 5fe:	8b bb       	out	0x1b, r24	; 27
 600:	08 95       	ret
		}
		else if(value==HIGH)
 602:	41 30       	cpi	r20, 0x01	; 1
 604:	09 f0       	breq	.+2      	; 0x608 <DIO_write+0x3a>
 606:	5c c0       	rjmp	.+184    	; 0x6c0 <DIO_write+0xf2>
		{
			PORTA |=(1<<pinNumber);//Write 1
 608:	2b b3       	in	r18, 0x1b	; 27
 60a:	81 e0       	ldi	r24, 0x01	; 1
 60c:	90 e0       	ldi	r25, 0x00	; 0
 60e:	02 c0       	rjmp	.+4      	; 0x614 <DIO_write+0x46>
 610:	88 0f       	add	r24, r24
 612:	99 1f       	adc	r25, r25
 614:	6a 95       	dec	r22
 616:	e2 f7       	brpl	.-8      	; 0x610 <DIO_write+0x42>
 618:	82 2b       	or	r24, r18
 61a:	8b bb       	out	0x1b, r24	; 27
 61c:	08 95       	ret
			//Error handling Technique
		}
		break;
		
		case PORT_B:
		if (value==LOW)
 61e:	41 11       	cpse	r20, r1
 620:	0c c0       	rjmp	.+24     	; 0x63a <DIO_write+0x6c>
		{
			PORTB &=~(1<<pinNumber);//Write 0
 622:	28 b3       	in	r18, 0x18	; 24
 624:	81 e0       	ldi	r24, 0x01	; 1
 626:	90 e0       	ldi	r25, 0x00	; 0
 628:	02 c0       	rjmp	.+4      	; 0x62e <DIO_write+0x60>
 62a:	88 0f       	add	r24, r24
 62c:	99 1f       	adc	r25, r25
 62e:	6a 95       	dec	r22
 630:	e2 f7       	brpl	.-8      	; 0x62a <DIO_write+0x5c>
 632:	80 95       	com	r24
 634:	82 23       	and	r24, r18
 636:	88 bb       	out	0x18, r24	; 24
 638:	08 95       	ret
		}
		else if(value==HIGH)
 63a:	41 30       	cpi	r20, 0x01	; 1
 63c:	09 f0       	breq	.+2      	; 0x640 <DIO_write+0x72>
 63e:	40 c0       	rjmp	.+128    	; 0x6c0 <DIO_write+0xf2>
		{
			PORTB |=(1<<pinNumber);//Write 1
 640:	28 b3       	in	r18, 0x18	; 24
 642:	81 e0       	ldi	r24, 0x01	; 1
 644:	90 e0       	ldi	r25, 0x00	; 0
 646:	02 c0       	rjmp	.+4      	; 0x64c <DIO_write+0x7e>
 648:	88 0f       	add	r24, r24
 64a:	99 1f       	adc	r25, r25
 64c:	6a 95       	dec	r22
 64e:	e2 f7       	brpl	.-8      	; 0x648 <DIO_write+0x7a>
 650:	82 2b       	or	r24, r18
 652:	88 bb       	out	0x18, r24	; 24
 654:	08 95       	ret
			//Error handling Technique
		}
		break;
		
		case PORT_C:
		if (value==LOW)
 656:	41 11       	cpse	r20, r1
 658:	0c c0       	rjmp	.+24     	; 0x672 <DIO_write+0xa4>
		{
			PORTC &=~(1<<pinNumber);//Write 0
 65a:	25 b3       	in	r18, 0x15	; 21
 65c:	81 e0       	ldi	r24, 0x01	; 1
 65e:	90 e0       	ldi	r25, 0x00	; 0
 660:	02 c0       	rjmp	.+4      	; 0x666 <DIO_write+0x98>
 662:	88 0f       	add	r24, r24
 664:	99 1f       	adc	r25, r25
 666:	6a 95       	dec	r22
 668:	e2 f7       	brpl	.-8      	; 0x662 <DIO_write+0x94>
 66a:	80 95       	com	r24
 66c:	82 23       	and	r24, r18
 66e:	85 bb       	out	0x15, r24	; 21
 670:	08 95       	ret
		}
		else if(value==HIGH)
 672:	41 30       	cpi	r20, 0x01	; 1
 674:	29 f5       	brne	.+74     	; 0x6c0 <DIO_write+0xf2>
		{
			PORTC |=(1<<pinNumber);//Write 1
 676:	25 b3       	in	r18, 0x15	; 21
 678:	81 e0       	ldi	r24, 0x01	; 1
 67a:	90 e0       	ldi	r25, 0x00	; 0
 67c:	02 c0       	rjmp	.+4      	; 0x682 <DIO_write+0xb4>
 67e:	88 0f       	add	r24, r24
 680:	99 1f       	adc	r25, r25
 682:	6a 95       	dec	r22
 684:	e2 f7       	brpl	.-8      	; 0x67e <DIO_write+0xb0>
 686:	82 2b       	or	r24, r18
 688:	85 bb       	out	0x15, r24	; 21
 68a:	08 95       	ret
			//Error handling Technique
		}
		break;
		
		case PORT_D:
		if (value==LOW)
 68c:	41 11       	cpse	r20, r1
 68e:	0c c0       	rjmp	.+24     	; 0x6a8 <DIO_write+0xda>
		{
			PORTD &=~(1<<pinNumber);//Write 0
 690:	22 b3       	in	r18, 0x12	; 18
 692:	81 e0       	ldi	r24, 0x01	; 1
 694:	90 e0       	ldi	r25, 0x00	; 0
 696:	02 c0       	rjmp	.+4      	; 0x69c <DIO_write+0xce>
 698:	88 0f       	add	r24, r24
 69a:	99 1f       	adc	r25, r25
 69c:	6a 95       	dec	r22
 69e:	e2 f7       	brpl	.-8      	; 0x698 <DIO_write+0xca>
 6a0:	80 95       	com	r24
 6a2:	82 23       	and	r24, r18
 6a4:	82 bb       	out	0x12, r24	; 18
 6a6:	08 95       	ret
		}
		else if(value==HIGH)
 6a8:	41 30       	cpi	r20, 0x01	; 1
 6aa:	51 f4       	brne	.+20     	; 0x6c0 <DIO_write+0xf2>
		{
			PORTD |=(1<<pinNumber);//Write 1
 6ac:	22 b3       	in	r18, 0x12	; 18
 6ae:	81 e0       	ldi	r24, 0x01	; 1
 6b0:	90 e0       	ldi	r25, 0x00	; 0
 6b2:	02 c0       	rjmp	.+4      	; 0x6b8 <DIO_write+0xea>
 6b4:	88 0f       	add	r24, r24
 6b6:	99 1f       	adc	r25, r25
 6b8:	6a 95       	dec	r22
 6ba:	e2 f7       	brpl	.-8      	; 0x6b4 <DIO_write+0xe6>
 6bc:	82 2b       	or	r24, r18
 6be:	82 bb       	out	0x12, r24	; 18
 6c0:	08 95       	ret

000006c2 <DIO_read>:
	}
}

void DIO_read(uint8_t portNumber, uint8_t pinNumber, uint8_t *value)
{
	switch(portNumber)
 6c2:	82 34       	cpi	r24, 0x42	; 66
 6c4:	01 f1       	breq	.+64     	; 0x706 <DIO_read+0x44>
 6c6:	18 f4       	brcc	.+6      	; 0x6ce <DIO_read+0xc>
 6c8:	81 34       	cpi	r24, 0x41	; 65
 6ca:	39 f0       	breq	.+14     	; 0x6da <DIO_read+0x18>
 6cc:	08 95       	ret
 6ce:	83 34       	cpi	r24, 0x43	; 67
 6d0:	81 f1       	breq	.+96     	; 0x732 <DIO_read+0x70>
 6d2:	84 34       	cpi	r24, 0x44	; 68
 6d4:	09 f4       	brne	.+2      	; 0x6d8 <DIO_read+0x16>
 6d6:	43 c0       	rjmp	.+134    	; 0x75e <DIO_read+0x9c>
 6d8:	08 95       	ret
	{
		case PORT_A:
		*value = (PINA & (1<<pinNumber))>>pinNumber; // get state -> read bit 0 or 1
 6da:	79 b3       	in	r23, 0x19	; 25
 6dc:	81 e0       	ldi	r24, 0x01	; 1
 6de:	90 e0       	ldi	r25, 0x00	; 0
 6e0:	9c 01       	movw	r18, r24
 6e2:	06 2e       	mov	r0, r22
 6e4:	02 c0       	rjmp	.+4      	; 0x6ea <DIO_read+0x28>
 6e6:	22 0f       	add	r18, r18
 6e8:	33 1f       	adc	r19, r19
 6ea:	0a 94       	dec	r0
 6ec:	e2 f7       	brpl	.-8      	; 0x6e6 <DIO_read+0x24>
 6ee:	87 2f       	mov	r24, r23
 6f0:	90 e0       	ldi	r25, 0x00	; 0
 6f2:	82 23       	and	r24, r18
 6f4:	93 23       	and	r25, r19
 6f6:	02 c0       	rjmp	.+4      	; 0x6fc <DIO_read+0x3a>
 6f8:	95 95       	asr	r25
 6fa:	87 95       	ror	r24
 6fc:	6a 95       	dec	r22
 6fe:	e2 f7       	brpl	.-8      	; 0x6f8 <DIO_read+0x36>
 700:	fa 01       	movw	r30, r20
 702:	80 83       	st	Z, r24
		break;
 704:	08 95       	ret
		
		case PORT_B:
		*value = (PINB & (1<<pinNumber))>>pinNumber; // get state -> read bit 0 or 1
 706:	76 b3       	in	r23, 0x16	; 22
 708:	81 e0       	ldi	r24, 0x01	; 1
 70a:	90 e0       	ldi	r25, 0x00	; 0
 70c:	9c 01       	movw	r18, r24
 70e:	06 2e       	mov	r0, r22
 710:	02 c0       	rjmp	.+4      	; 0x716 <DIO_read+0x54>
 712:	22 0f       	add	r18, r18
 714:	33 1f       	adc	r19, r19
 716:	0a 94       	dec	r0
 718:	e2 f7       	brpl	.-8      	; 0x712 <DIO_read+0x50>
 71a:	87 2f       	mov	r24, r23
 71c:	90 e0       	ldi	r25, 0x00	; 0
 71e:	82 23       	and	r24, r18
 720:	93 23       	and	r25, r19
 722:	02 c0       	rjmp	.+4      	; 0x728 <DIO_read+0x66>
 724:	95 95       	asr	r25
 726:	87 95       	ror	r24
 728:	6a 95       	dec	r22
 72a:	e2 f7       	brpl	.-8      	; 0x724 <DIO_read+0x62>
 72c:	fa 01       	movw	r30, r20
 72e:	80 83       	st	Z, r24
		break;
 730:	08 95       	ret
		
		case PORT_C:
		*value = (PINC & (1<<pinNumber))>>pinNumber; // get state -> read bit 0 or 1
 732:	73 b3       	in	r23, 0x13	; 19
 734:	81 e0       	ldi	r24, 0x01	; 1
 736:	90 e0       	ldi	r25, 0x00	; 0
 738:	9c 01       	movw	r18, r24
 73a:	06 2e       	mov	r0, r22
 73c:	02 c0       	rjmp	.+4      	; 0x742 <DIO_read+0x80>
 73e:	22 0f       	add	r18, r18
 740:	33 1f       	adc	r19, r19
 742:	0a 94       	dec	r0
 744:	e2 f7       	brpl	.-8      	; 0x73e <DIO_read+0x7c>
 746:	87 2f       	mov	r24, r23
 748:	90 e0       	ldi	r25, 0x00	; 0
 74a:	82 23       	and	r24, r18
 74c:	93 23       	and	r25, r19
 74e:	02 c0       	rjmp	.+4      	; 0x754 <DIO_read+0x92>
 750:	95 95       	asr	r25
 752:	87 95       	ror	r24
 754:	6a 95       	dec	r22
 756:	e2 f7       	brpl	.-8      	; 0x750 <DIO_read+0x8e>
 758:	fa 01       	movw	r30, r20
 75a:	80 83       	st	Z, r24
		break;
 75c:	08 95       	ret
		
		case PORT_D:
		*value = (PIND & (1<<pinNumber))>>pinNumber; // get state -> read bit 0 or 1
 75e:	70 b3       	in	r23, 0x10	; 16
 760:	81 e0       	ldi	r24, 0x01	; 1
 762:	90 e0       	ldi	r25, 0x00	; 0
 764:	9c 01       	movw	r18, r24
 766:	06 2e       	mov	r0, r22
 768:	02 c0       	rjmp	.+4      	; 0x76e <DIO_read+0xac>
 76a:	22 0f       	add	r18, r18
 76c:	33 1f       	adc	r19, r19
 76e:	0a 94       	dec	r0
 770:	e2 f7       	brpl	.-8      	; 0x76a <DIO_read+0xa8>
 772:	87 2f       	mov	r24, r23
 774:	90 e0       	ldi	r25, 0x00	; 0
 776:	82 23       	and	r24, r18
 778:	93 23       	and	r25, r19
 77a:	02 c0       	rjmp	.+4      	; 0x780 <DIO_read+0xbe>
 77c:	95 95       	asr	r25
 77e:	87 95       	ror	r24
 780:	6a 95       	dec	r22
 782:	e2 f7       	brpl	.-8      	; 0x77c <DIO_read+0xba>
 784:	fa 01       	movw	r30, r20
 786:	80 83       	st	Z, r24
 788:	08 95       	ret

0000078a <_exit>:
 78a:	f8 94       	cli

0000078c <__stop_program>:
 78c:	ff cf       	rjmp	.-2      	; 0x78c <__stop_program>
